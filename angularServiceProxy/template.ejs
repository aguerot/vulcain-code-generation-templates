import { Http, Response, RequestOptions, Headers } from '@angular/http';
import { Observable } from 'rxjs';

interface VulcainResponse<T> {
    value: T;
    status: "Success" | "Error" | "Pending";
    error?: {
        message: string;
        errors?: Array<{message: string}>;
    }
}

// Models
<% for(let model of schemas) { %>
/**
* <%= model.description %>
*/
export class <%= model.name%> { 
<% for(let prop of model.properties) {
    if(prop.description) { _%>
    /**
    * <%= prop.description %>
    */
  <%} -%>    
    <%= prop.name%>: <%= prop.type %>;
<%} -%>
}
<%}%>

// Service proxy
export class <%= normalizeService(serviceName) %> {

    constructor(public http: Http, protected baseUrl: string) {
    }

    protected abstract httpOptions(): RequestOptions;
    protected abstract onUnauthenticated();

    protected sendAction<T>(verb: string, data, args?): Observable<T> {
        return this.http
            .post( this.resolveBackendUrl( this.baseUrl + verb, args), data, this.httpOptions())
            .map((response: Response) => {
                if(response.status != 200) {
                    return this.handleError(response);
                }
                let res = <VulcainResponse<T>>response.json();
                if(res && res.error) {
                    const error = res.error;
                    console.log(error);
                    return Observable.throw(error);
                }                
                return res && res.value;
            })
            .do(data => console.log(data))
            .catch(this.handleError.bind(this));
    }

    protected query<T>(verb: string, query?, page?: number, maxByPage?:number, args?): Observable<{page: number, total: number, values: T}> {
        if( page || maxByPage) {
            query = query || {};
            query.$page = page;
            query.$maxByPage = maxByPage;
        }
        return this.http
            .get( this.resolveBackendUrl(this.baseUrl + verb, query, args), this.httpOptions())
            .map((response: Response) => {
                if(response.status != 200) {
                    return this.handleError(response);
                }
                let res = <VulcainResponse<T>>response.json();
                if(res && res.error) {
                    const error = res.error;
                    console.log(error);
                    return Observable.throw(error);
                }                
                return {values: res && res.value, page: page};
            })
            .do(data => console.log(data))
            .catch(this.handleError.bind(this));
    }

    protected get<T>(verb: string, id: string, args?): Observable<T> {
        return this.http
            .get( this.resolveBackendUrl(this.baseUrl + verb + "/" + id, args), this.httpOptions())
            .map((response: Response) => {
                if(response.status != 200) {
                    return this.handleError(response);
                }
                let res = <VulcainResponse<T>>response.json();
                if(res && res.error) {
                    const error = res.error;
                    console.log(error);
                    return Observable.throw(error);
                }
                return res && res.value;
            })
            .do(data => console.log(data))
            .catch(this.handleError.bind(this));
    }

    protected handleError(error: Response) {
        console.error(error);
        if(error && error.status === 401) {
            this.onUnauthenticated();
            return;
        }
        let msg = {status: error.status, message:`Error status code ${error.status} at ${error.url}`};
        return Observable.throw(msg);
    }

   resolveBackendUrl(baseurl: string, ...urlSegments: (string | any)[]): string {

        if (urlSegments) {
            baseurl += urlSegments.filter((s: any) => typeof s === 'string').map((s: string) => encodeURIComponent(s)).join('/');
            let query = urlSegments.filter((s: any) => s && typeof s !== 'string');
            if (query.length) {
                let sep = '?';
                query.forEach((obj: any) => {
                    for (let p in obj) {
                        if (!obj.hasOwnProperty(p)) {
                            continue;
                        }
                        if(obj[p] !== undefined) {
                            baseurl = baseurl.concat(sep, p, '=', encodeURIComponent(obj[p]));
                            sep = '&';
                        }
                    }
                });
            }
            return baseurl;
        } else {
            return baseurl;
        }
    }

<% for(let method of services) {
    let p = arguments(method);    
    if( method.kind == "action") { %>
    /**
    * Action: <%= method.description %>
    <%_ for(let p of getInputProperties(method)) { _%>
    * @params {<%= p.type %>} <%= p.name %> - <%= p.description %>
    <%_ } -%>
    */
    <%=normalizeMethod(method.verb)%><T>(<%=p.params.join('')%> args?): Observable<T> {
        let response = this.sendAction<T>("<%=method.verb%>", <%=p.args%>, args);
        return response;
    }
    <% } else if( method.kind === "get" ) { %>
    /**
    * <%= method.description || "Get" %>
    * @params id string - unique id
    */
    <%=normalizeMethod(method.verb, 'get')%><T>(<%= p.params.join('')%> args?): Observable<T> {
        let response = this.get<T>("<%=method.verb%>", <%=p.args%>, args);
        return response;
    }
    <% } else if(method.kind === "query" && method.action === "all") {
    %>
    /**
    * <%= method.description || "Get all" %>
    <%_ for(let p of getInputProperties(method)) { _%>
    * @params {<%= p.type %>} <%= p.name %> - <%= p.description %>
    <%_ } _%>
    * @params {number} page - Page to retrieve
    * @params {number} maxByPage - Item by page (default 100)
    */
    <%=normalizeMethod(method.verb, 'getAll')%><T>(<%= p.params.join('')%> page?: number, maxByPage?: number, args?) {
        let response = this.query<T>("<%=method.verb%>", <%=p.args%>, page, maxByPage, args);
        return response;
    }
    <% } else {
    %>
    /**
    * Query: <%= method.description %>
    <%_ for(let p of getInputProperties(method)) { _%>
    * @params {<%= p.type %>} <%= p.name %> - <%= p.description %>
    <%_ } _%>
    */
    <%=normalizeMethod(method.verb, 'get')%><T>(<%= p.params.join('')%> page?: number, maxByPage?: number, args?) {
        let response = this.query<T>("<%=method.verb%>", <%=p.args%>, page, maxByPage, args);
        return response;
    }
<% }
}%>
}
