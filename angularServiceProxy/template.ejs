import { Http, Response, RequestOptions, Headers } from '@angular/http';
import { Observable } from 'rxjs';

interface VulcainResponse<T> {
    value: T;
    status: "Success" | "Error" | "Pending";
    error?: {
        message: string;
        errors?: Array<{message: string}>;
    }
}

// Models
<% for(let model of schemas) { %>
/**
* <%= model.description %>
*/
export class <%= model.name%> { 
<% for(let prop of model.properties) {
    if(prop.description) { _%>
    /**
    * <%= prop.description %>
    */
  <%} -%>    
    <%= prop.name%><%= required(prop)%>: <%= prop.type %>;
<%} -%>
}
<%}%>

// Service proxy
export abstract class <%= normalizeService(serviceName) %> {

    constructor(public http: Http, protected baseUrl: string) {
    }

    protected abstract httpOptions(): RequestOptions;
    protected abstract onUnauthenticated();
    protected onError(msg: string) {}

    protected sendAction<T>(verb: string, data, args?): Observable<T> {
        return this.http
            .post( this.resolveBackendUrl( this.baseUrl + verb, args), data, this.httpOptions())
            .map((response: Response) => {
                let res = <VulcainResponse<T>>response.json();            
                return res && res.value;
            })
            .do(data => console.log(data))
            .catch(this.handleError.bind(this));
    }

    protected query<T>(verb: string, args?, page?: number, maxByPage?:number, query?): Observable<{page: number, total: number, values: T}> {
        if( page || maxByPage || query) {
            args = args || {};
            args.$page = page;
            args.$maxByPage = maxByPage;
            args.$query = JSON.stringify(query)
        }
        return this.http
            .get( this.resolveBackendUrl(this.baseUrl + verb, args), this.httpOptions())
            .map((response: Response) => {
                let res = <VulcainResponse<T>>response.json();           
                return {values: res && res.value, page: page};
            })
            .do(data => console.log(data))
            .catch(this.handleError.bind(this));
    }

    protected get<T>(verb: string, id: string|any, args?): Observable<T> {
        let url = this.baseUrl + verb;
        if(typeof id === "string") {
            url = url + "/" + id;
            id = null;
        }
        return this.http
            .get( this.resolveBackendUrl(url, id, args), this.httpOptions())
            .map((response: Response) => {
                let res = <VulcainResponse<T>>response.json();
                return res && res.value;
            })
            .do(data => console.log(data))
            .catch(this.handleError.bind(this));
    }

    protected handleError(res: Response) {
        if (res && res.status === 401) {
            console.error("Unauthenticated");        
            let res = this.onUnauthenticated();
            return res || Observable.throw(new Error("Unauthenticated"));
        }

        let message = `Error status code ${res.status} at ${res.url}`;
        if(res instanceof Response) {
            try {
                let body = <any>res.json();
                if(body && body.error) {
                    const error = body.error;
                    console.log(error);
                    let message = "<b>" + (error.message) + "</b>";
                    if (error.errors) {
                        message =  message + " :<br/>" + error.errors.map(m=>m.message).join('</br>');
                    }
                }    
            }
            catch(e) {/*ignore*/}    
        }

        this.onError(message);
        return Observable.throw(new Error(message));
    }

   resolveBackendUrl(baseurl: string, ...urlSegments: (string | any)[]): string {

        let hasQueryPoint = baseurl.includes("?");
        if (urlSegments) {
            baseurl += "/";

            let paths: Array<string> = urlSegments.filter((s: any) => typeof s === 'string');

            if (hasQueryPoint && paths.length >= 1) {
                throw new Error('You can\'t have a path on your url after a query string');
            } else {
                baseurl += paths.map((s: string) => encodeURIComponent(s)).join('/');
            }

            let query = urlSegments.filter((s: any) => s && typeof s !== 'string');
            if (query.length) {
                let sep = hasQueryPoint ? "&" : '?';
                query.forEach((obj: any) => {
                    for (let p in obj) {
                        if (!obj.hasOwnProperty(p)) {
                            continue;
                        }
                        if (obj[p]) {
                            baseurl = baseurl.concat(sep, p, '=', encodeURIComponent(obj[p]));
                            sep = '&';
                        }
                    }
                });
            }
            return baseurl;
        } else {
            return baseurl;
        }
    }

<% for(let method of services) {
    let p = arguments(method);    
    if( method.kind == "action") { %>
    /**
    * Action: <%= method.description %>
    <%_ for(let p of getInputProperties(method)) { _%>
    * @params {<%= p.type %>} <%= p.name %> - <%= p.description %>
    <%_ } -%>
    * @params [optional] args - additional url parameters
    */
<%_ if( method.inputSchema) { _%>
    <%=normalizeMethod(method.verb)%><T>(<%=p.params.join('')%> args?): Observable<T> {
        let _data = <%=p.args%>;        
        return this.<%=normalizeMethod(method.verb)%>Entity<T>(_data, args);
    }

    /**
    * Action: <%= method.description %>
    * @params {<%= method.inputSchema %>} entity - 
    * @params [optional] args - additional url parameters    
    */     
    <%=normalizeMethod(method.verb)%>Entity<T>(data: <%= method.inputSchema %>, args?): Observable<T> {
        return this.sendAction<T>("<%=method.verb%>", data, args);     
    }    
<%_ } else { -%>
    <%=normalizeMethod(method.verb)%><T>(<%=p.params.join('')%> args?): Observable<T> {
        let data = <%=p.args%>;        
        let response = this.sendAction<T>("<%=method.verb%>", data, args);
        return response;
    }
<%_ } -%>    
    <% } else if( method.kind === "get" ) { %>
    /**
    * <%= method.description || "Get" %>
    * @params id string - unique id
    */
    <%=normalizeMethod(method.verb, 'get')%><T>(<%= p.params.join('')%>): Observable<T> {

        let response = this.get<T>("<%=method.verb%>", id, <%=p.args%>);
        return response;
    }
    <% } else if(method.kind === "query" && method.action === "all") {
    %>
    /**
    * <%= method.description || "Get all" %>
    <%_ for(let p of getInputProperties(method)) { _%>
    * @params {<%= p.type %>} <%= p.name %> - <%= p.description %>
    <%_ } _%>
    * @params [optional] query - filter query         
    * @params {number} page - Page to retrieve
    * @params {number} maxByPage - Item by page (default 100)
    */
    <%=normalizeMethod(method.verb, 'getAll')%><T>(<%= p.params.join('')%> query?, page?: number, maxByPage?: number) {
        let response = this.query<T>("<%=method.verb%>", <%=p.args%>, page, maxByPage, query);
        return response;
    }
    <% } else {
    %>
    /**
    * Query: <%= method.description %>
    <%_ for(let p of getInputProperties(method)) { _%>
    * @params {<%= p.type %>} <%= p.name %> - <%= p.description %>
    <%_ } _%>
<%_ if(method.outputType === "one") { _%> 
    * @params [optional] args - additional url parameters    
    */
    <%=normalizeMethod(method.verb, 'get')%><T>(<%= p.params.join('')%> args?) {
        let response = this.get<T>("<%=method.verb%>", <%=p.args%>, args);
        return response;
    }
<%_ } else { _%>           
    * @params {number} page - Page to retrieve
    * @params {number} maxByPage - Item by page (default 100)
    */
    <%=normalizeMethod(method.verb, 'get')%><T>(<%= p.params.join('')%> page?: number, maxByPage?: number) {
        let response = this.query<T>("<%=method.verb%>", <%=p.args%>, page, maxByPage);
        return response;
    }
<%_ } _%>
<% }
}%>
}
